# 数据库复习



## 第一章

数据库：**长期存储在计算机内、有组织的、大量的、共享的数据集合**

数据库管理系统：**位于用户与操作系统之间的一层数据管理软件，为用户或应用程序提供访问数据库的方法和接口**

数据库技术：**研究数据库的结构、存储、设计、管理和使用的一门软件学科**

在两层C/S架构中：数据库和DBMS运行在数据库服务器(server)中，数据库应用程序运行在客户机（client)中，两者之间通过局域网实现数据访问
在三层B/S架构中：数据库和DBMS运行在数据库服务器中，数据库应用程序运行在应用服务器（也称“Web服务器”）中，用户客户端只需要安装常用的浏览器，负责接收用户输入和结果展示。

数据模型：主要学习关系对象模型

## 第二章  关系代数

### 概念：

* 笛卡尔乘积：![image-20191230174227118](C:\Users\Jaqen\AppData\Roaming\Typora\typora-user-images\image-20191230174227118.png)

关系规则：

* **First Normal Form Rule**

  columns that have multi-valued attributes (repeating fields) or have any internal structure (record) are not permitted

  比如name里不能有Iname和fname

* **Access Rows by Content Only Rule**

  can only retrieve rows by their content, the attribute values that exist in each row

* **The Unique Row Rule**

  两行不能所有属性取值都相同

superkey超键：**is a set of columns that has the uniqueness property**，一个超键可能有许多个属性，但它能区分开所有的行

key键：**is a minimal superkey: no subset of columns also has uniqueness property**，最小的超键，去除其中一个元素之后就不能区分开所有行

candidata key 候选关键字：一个表中的键的别名

primary key 主关键字：**the** **candidate key** **chosen by the designer to identifies rows of T used in references by other tables.**

![image-20191230202045791](C:\Users\Jaqen\AppData\Roaming\Typora\typora-user-images\image-20191230202045791.png)

### 关系代数：

相容表：有相同headings的两个表 Head(R)=Head(S),with attributes chosen from the same domains and with the same meanings

关系的交、并、差：

![](C:\Users\Jaqen\Desktop\temp\2_1.png)

赋值运算：**S(B_1,B2,…,Bn) := R(A_1,A2,…,An)**

笛卡尔乘积：T=R x S , Head(T)={R.A1,...,R.An, S.B1,...,S.Bm}, 对于R中的每一行，它和S中的所有m行接在一起成为T中的m行。

投影($\pi$)：![](C:\Users\Jaqen\Desktop\temp\2_2.png)

选择($\delta$) : 有表 S， S where C 或 $\delta_C (S)$ ,C 为条件

![](file:///C:\Users\Jaqen\AppData\Roaming\Tencent\Users\1213714744\QQ\WinTemp\RichOle\WR]4N0T7%7_J8`TLN$36GQ1.png)

R2中即为除去了最大的cid

连接($\infty$)： R join($\infty$) S :

![](C:\Users\Jaqen\Desktop\temp\2——3.png)

相同的列连接在一起

除法： T=R/S， T 包含了最大子集

![](C:\Users\Jaqen\Desktop\temp\2_4.png)

各种连接：

![](C:\Users\Jaqen\Desktop\temp\2_5.png)

课后练习：2.1，2.2，2.4，2.5

## 第三章 SQL

structured query language, 不区分大小写

创建表： create tabel:

<img src="C:\Users\Jaqen\Desktop\temp\3_1.png" style="zoom:50%;" />

选择： select a1,a2,.. from r1,... where condition, 如 select (distinct) aid,aname from agents where city='new york'

<img src="C:\Users\Jaqen\Desktop\temp\3_2.png" style="zoom:50%;" />



<img src="C:\Users\Jaqen\Desktop\temp\3_3.png" style="zoom:50%;" />

选择一个东西，这个东西是别人通过什么什么得来的：

<img src="C:\Users\Jaqen\Desktop\temp\3_4.png" style="zoom:33%;" />

关系代数中的自然连接在SQL： IN, =SOME, =ANY,EXISTS

关系代数中的除法在SQL： NOT IN, <> ALL, NOT EXISTS

UNION: subquery union (all) subquery, 加了all,可能有重复的行

<img src="C:\Users\Jaqen\Desktop\temp\3_5.png" style="zoom:33%;" />

两个not exist的神奇运用：

<img src="C:\Users\Jaqen\Desktop\temp\3_6.png" style="zoom: 33%;" />

<img src="C:\Users\Jaqen\Desktop\temp\3_7.png" style="zoom:33%;" />

<img src="C:\Users\Jaqen\Desktop\temp\3_8.png" style="zoom:33%;" />

<img src="C:\Users\Jaqen\Desktop\temp\3_9.png" style="zoom:33%;" />

union, intersect:返回查询结果中相同的部分既他们的交集,自动去重，否则可以加 ALL

minus: 返回在第一个查询结果中与第二个查询结果不相同的那部分行记录,
即两个结果的差集

except:返回两个结果集的差（即从左查询中返回右查询没有找到的所有非重复值）

SQL中的函数：count,sum,avg,max,min,只在select和having子句中用

例子：  select sum(qty) as total from orders where pid='p03' 

count: 返回匹配条件的行数

<img src="C:\Users\Jaqen\Desktop\temp\3_10.png" style="zoom:33%;" />

在使用带group by子句的分组统计查询时，除了统计函数外，目标属性必须包含且仅包含所有分组属性

<img src="C:\Users\Jaqen\Desktop\temp\3_11.png" style="zoom:33%;" />

**Find the average, over all agents, of the maximum dollar sales made by each agent**：SELECT avg ( t.x )

FROM  ( select aid, max(dollars) as x

 from  orders

 group by aid )  t ;

order by: 对结果集排序 order by a1,a2 (desc)

* insert: INSERT INTO 表名称 VALUES (值1, 值2,....)

​      INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)

* update: UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值

​        UPDATE agents SET percent = 1.1* percent WHERE city = ‘New York’

* delete: DELETE FROM 表名称 WHERE 列名称 = 值

  delete from agents where aid in (select aid from orders group by aid having sum(dollars)<600)

## 第五章 访问数据库的程序

嵌入式SQL(ESQL): 语句前要有 exec sql

游标：查询多个数据的时候需要使用游标进行查询，经常配合循环使用来获取多个数据

* 游标的声明：EXEC SQL DECLARE <游标名> CURSOR FOR SELECT …FROM…WHERE…;  示例：ECEX SQL DECLARE RC_QRY  CURSOR FOR SELECT l From STUDENT WHERE ID =:s_id

* 打开游标：在打开游标时，执行与游标相联系的SQL查询语句。此时游标处于打开状态，游标指向第一个元组之前。EXEC SQL OPEN <游标名>

* 移动游标：EXEC SQL FETCH <游标名> INTO <变量表> 移动赋值给共享变量

* 关闭游标：EXEC SQL CLOSE <游标名>;

事务：一个事务是指由一条SQL语句或者一组SQL语句所构成的一个执行过程，并具有ACID四个特性。事务是恢复和并发控制的基本单位

事务的ACID特性：

* 原子性 Atomicity
* 一致性 Consistency
* 隔离性 Isolation
* 持久性 Durability

事务的开始，

事务的结束： 正常结束：提交事务(commit);非正常：回退事务(rollback)

## 第六章 数据库设计

### ER模型

Entity-Relationship(ER) model is an abstract way to describe a databas

基本组成：实体(entity)，属性(attribute)，联系(relationship)

identifier: an attribute or set of attributes that uniquely identifies an entity instance

descriptor: a non-key attribute

![image-20191231151612737](C:\Users\Jaqen\AppData\Roaming\Typora\typora-user-images\image-20191231151612737.png)

* 转换规则1： 每一个实体映射到关系数据库中的一个表，并用实体名来命名这个表，表的列代表了连接到实体的所有简单单值属性(复合属性拆成单值)<img src="C:\Users\Jaqen\AppData\Roaming\Typora\typora-user-images\image-20191231152004487.png" alt="image-20191231152004487" style="zoom:150%;" />

* 转换规则2：<img src="C:\Users\Jaqen\AppData\Roaming\Typora\typora-user-images\image-20191231152143547.png" alt="image-20191231152143547" />![image-20191231152226029](C:\Users\Jaqen\AppData\Roaming\Typora\typora-user-images\image-20191231152226029.png)

联系 Relationship: R定义了这些实体实例之间的对应规则，R的度为实体数目

![image-20191231161226387](C:\Users\Jaqen\AppData\Roaming\Typora\typora-user-images\image-20191231161226387.png)

define:card(E,R) = (a,b), 所有E当中的instance连接的R中的instance最少有a个，最多有b个。

1-1，1-N，N-N：

![image-20191231163035324](C:\Users\Jaqen\AppData\Roaming\Typora\typora-user-images\image-20191231163035324.png)

* If min-card(E,R) = 1, E is said to have mandatory participation (强制参与) in the relationship R

* if min-card(E,R) = 0, then E is said to be optional participation (可选参与) in this relationship

* 转换规则3：![image-20191231164814855](C:\Users\Jaqen\AppData\Roaming\Typora\typora-user-images\image-20191231164814855.png)

* 转换规则4，N-1的relation，max-card(E,R)=N,max-card(F,R)=1。将联系合并到many side对应的F当中增加以下属性：E的主关键字属性，R上的所有属性：![image-20191231165320348](C:\Users\Jaqen\AppData\Roaming\Typora\typora-user-images\image-20191231165320348.png)
* 1-1 relationship:
  * Optional on both side:用三张表来表示
  * Optional on one side: 用两张表来表示，在其中一张表中加入一个非空的foreign key
  * Mandatory on both side:用一张表来表示
* N-ary relationship:按照N-N二元联系的转换方式，转换后需要进行规范化设计

联系(relationship)在E-R图中用菱形符号来表示。

在相关实体集(entity)与联系之间用无向线段相连接

### Normalization

在一个关系当中，属性与属性之间需要满足一定的约束条件，这样的约束条件我们称之为“范式”，不同的约束条件构成了不同级别的范式定义。

##### Fuctional Dependency(函数依赖)

constraint between two sets of attributes in a relation from a database.

$A \rightarrow B$ 如果两行的A属性相同，则B属性也相同被称作A functionally determines B

**Armstrong’s Axioms**

* 自反规则：$Y \subset X$,then $X \rightarrow Y$
* 传递规则：if $X \rightarrow Y$ and $Y \rightarrow Z$, then $X \rightarrow Z$
* 增广规则：if $X \rightarrow Y$, then $XZ \rightarrow YZ$
* 合并规则：if $X \rightarrow Y$ and $X \rightarrow Z$, then $X \rightarrow YZ$
* 分解规则：if $X \rightarrow YZ$, then $X \rightarrow Y$, and $X \rightarrow Z$
* 伪传递规则：if $X \rightarrow Y$, and $WY \rightarrow Z$, then $XW \rightarrow Z$
* 聚积规则：if $X \rightarrow YZ$ and $Z \rightarrow W$, then $X \rightarrow YZW$

**寻找最小函数依赖**

* 首先考虑决定因素和依赖因素都是单个属性的情况

* 其次考虑决定因素是多个属性的情况，根据Armstrong’s Axioms来进行筛选

* Closure of a Set of FDs(set of all FDs implied by F)

* FD Set Cover(函数依赖集的覆盖，彼此等价)

* Closure of a Set of Attributes（给定属性functional determine的所有属性的闭包），算法是找到所有子集属性的函数依赖后继属性

  <img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20191129165731936.png" alt="image-20191129165731936" style="zoom: 67%;" />

* Minimal Cover:

  * 右属性单一化
  * 去掉冗余的依赖
  * 判断左属性的冗余

* 无损性分解和无损连接分解：有损分解指的是子表连接起来会丢失行

  充要条件是子表表头的交functional determine其中某个子表表头

* FD Preserved:  F上的每一个函数依赖都在其分解后的某一个关系上成立，则这个分解是保持依赖的。

  * 定理：X is a superkey of T iff X functionally determines all attributes in T
  * 进行分解的目标是达到更高一级的规范化程度，但是分解的同时必须考虑两个问题：**无损联接性**和**保持函数依赖**。 

* 主属性: 为Key的一部分

* 范式

  * 1NF： 在关系模式R中的每一个具体关系r中，如果每个属性值都是不可再分的最小数据单位，则称R是第一范式的关系。 

  * 2NF： 如果关系模式R（U，F）中的所有**非主属性**都完全依赖于**任意**候选关键字，则称关系R 是属于第二范式的。 //对于所有由F推导的函数依赖X->A(A是不在X中的单属性)，X不是任何键的真子集 

  * 3NF： 如果关系模式R（U，F）中的所有**非主属性**对**任何候选关键字**都**不**存在传递依赖，则称关系R是属于第三范式的 // **对于所有函数依赖X->A(A为单个属性且不在X中) 要么X是一个超键，要么A是T的一个主属性

  * BCNF： 如果关系模式R（U，F）的所有属性（包括主属性和非主属性）都不传递依赖于R的任何候选关键字，那么称关系R是属于BCNF的。或是关系模式R中，每个决定因素都包含关键字（而不是被关键字所包含）。

    ​                                                               从3NF到4NF的算法流程

     						  <img src="https://img-blog.csdn.net/20161229200451433?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmFuZmFuNDU2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" style="zoom:67%;" />

    

    <img src="https://img-blog.csdn.net/20161229200539106?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmFuZmFuNDU2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" style="zoom: 67%;" />

    <img src="https://img-blog.csdn.net/20161229200913938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmFuZmFuNDU2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" style="zoom:67%;" />

    <img src="https://img-blog.csdn.net/20161229200923360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmFuZmFuNDU2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" style="zoom:67%;" />

    ![img](https://img-blog.csdn.net/20180120191300341?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXV5YW5nX3o=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

* 小结

  * 目的：规范化目的是使结构更合理，消除存储异常，使数据冗余尽量小，便于插入、删除和更新 
  * 原则：遵从概念单一化原则，即一个关系模式描述一个实体或实体间的一种联系。规范的实质就是概念的单一化。 
  * 方法：将关系模式投影分解成两个或两个以上的关系模式。 
  * 要求：分解后的关系模式集合应当与原关系模式"等价"，即经过自然联接可以恢复原关系而不丢失信息，并保持属性间合理的联系。

### 算法：求最小函数依赖集

* 右边都分解为只有一个属性
* 划去一个函数X->Y，在新的函数集上计算X+，若X+包含Y，则可划去，重复
* 对于函数X->Y，若|X|>=2, 则对X的每个属性x，令H为原函数集，J为H将X->Y替换为(X-x)->Y, 若 （X-x）在H上的闭包等于在J上的闭包，则可以替换，如此重复。
* 将左边相同的合并在一起

### 算法：求关系R上的候选关键字

* 将函数集中的属性分为：
  * R: 只在函数右边出现的
  * L：只在函数左边出现的
  * LR：在左右都出现的
  * N：没出现的

* ![](C:\Users\Jaqen\Desktop\temp\候选码.png)

### 模式分解

* 在表T中，X是T的一个超键 iff X+=head(T)
* 主属性：键的一部分
* 无损分解并保持依赖分解到3NF：![](C:\Users\Jaqen\Desktop\temp\3NF.png)

* X->Y, Y依赖于X，或X决定Y，X被称为决定因素，Y被称为依赖因素

* X->Y, 若Y是X的子集，则称为平凡函数依赖，否则就是非平凡的
* ![image-20200102020351960](C:\Users\Jaqen\AppData\Roaming\Typora\typora-user-images\image-20200102020351960.png)

* ![image-20200102020401208](C:\Users\Jaqen\AppData\Roaming\Typora\typora-user-images\image-20200102020401208.png)

* 传递函数依赖： X->Y,（Y!->X） Y->Z, 称Z传递函数依赖于X
* 2NF：![image-20200102021409160](C:\Users\Jaqen\AppData\Roaming\Typora\typora-user-images\image-20200102021409160.png)

![](C:\Users\Jaqen\AppData\Roaming\Typora\typora-user-images\image-20200102021334725.png)

* 3NF：![](C:\Users\Jaqen\Desktop\temp\3NF_1.png)

* BCNF:![image-20200102022924555](C:\Users\Jaqen\AppData\Roaming\Typora\typora-user-images\image-20200102022924555.png)















## 第七章 完整性，视图，安全性和目录

列约束：

* not null vs. default null: 可以使用default定义成分，否则缺省值为NULL
* unique and not null: 候选关键字
* primary key子句：指定一列为主关键字
* check子句：该列的每一行必须满足其后的条件
* on delete rule，on update rule：
  1、RESTRICT：约束
      如果存在从数据，不允许删除(更新)主数据。
  2、NO ACTION
      如果存在从数据，不允许删除(更新)主数据。
  3、CASCADE：级联
      删除主数据，顺便也(更新)从数据。
  4、SET NULL
      删除主数据，从数据外键的值设为NULL。

Alter table:允许DBA改变原先在创建表时定义的表的结构

触发器（TRIGGER）是由事件来触发某个操作。这些事件包括INSERT语句、UPDATE语句和DELETE语句。当数据库系统执行这些事件时，会激活促发其执行相应的操作

视图：是从一个或多个表导出的虚拟的表，其内容由查询定义。具有普通表的结构，但是不实现数据存储。对视图的修改：单表视图一般用于查询和修改，会改变基本表的数据，多表视图一般用于查询，不会改变基本表的数据。

视图定义：It is a table that results from a subquery, but which has its own name (table name & attributes name)

视图性质：no data storage in its own right, just window on data it selects from

视图定义命令：**CREATE VIEW view_name [col_name] AS subquery[ WITH CHECK OPTION],** 例如： **CREATE VIEW cacities (ccity, acity ) AS SELECT c.city, a.city FROM customers c, agents a, orders o**

view中不允许排序。

作用和缺点：

* 简化了操作，把经常使用的数据定义为视图。
* 安全性，用户只能查询和修改能看到的数据
* 逻辑上的独立性，屏蔽了真实表的结构带来的影响。
* 性能差，限制修改

GRANT语句：grant 权限 on 数据库对象 to 用户

撤销权限：revoke 权限 on 数据库对象 from 用户