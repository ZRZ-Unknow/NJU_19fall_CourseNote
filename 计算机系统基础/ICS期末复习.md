# 虚拟内存

## 分页机制

+ 硬盘和主存间按页面为单位交换信息，VP：虚拟页，PP/PF:物理页
+ 未分配页：没有和任何内容相关联的页
+ 已分配页：代码和数据等有内容的区域关联
  + 缓存页：已调入主存
  + 未缓存页：还在硬盘上
+ 主存页框和虚拟页间采用全组相联映射，回写，
+ 页表：进程中每个虚拟页在页表中有一个页表项，内容包括该虚拟页的存放位置、有效位、修改位、使用位等
+ 访问时，若装入位为0，则发生缺页异常，处理程序根据其页表项的存放位置字段从磁盘中将所缺失的页面读出，找一个空闲的物理页框存放该页信息
+ 页表位于虚拟地址空间的内核空间，页表在主存的首地址记录在页表基址寄存器中

### 地址转换

+ 假设每个进程的虚拟地址空间有m页，主存中有n个页框
+ 虚拟地址空间分两个字段
  + 高位字段为虚拟页号
  + 低位字段为页内偏移地址

+ 主存物理地址
  + 高位为物理页号
  + 低位为页内偏移地址(**和虚拟地址的页内偏移地址相等**)

+ 地址转换过程
  + 根据页表基址寄存器找到主存中对应的页表起始位置
  + 以虚拟地址的虚拟页号作为索引，找到对应的页表项
  + 装入位为1时，取出物理页号，与虚拟地址中的页内地址拼接，形成访问主存时实际的物理地址
    + 虚拟地址：虚拟页号|页内地址
    + 拼接成实际物理地址： 物理页号|页内地址

+ 快表（TLB)：把页表中最活跃的几个页表项复制到高速缓存中，相应地称主存中的页表为慢表，**地址转换时，首先到快表中查找页表项**
+ 快表中表项由页表项内容加上**TLB标记字段**组成，TLB标记字段表示该表项取自页表中哪个虚拟页对应的页表项
  + 在全相联方式下，TLB标记字段就是该页表项对应的虚拟页号
  + 在组相联方式下，TLB标记字段对应虚拟页号的高位部分，而虚拟页号的低位部分作为**TLB组索引**用于选择TLB组

### TLB与cache的访问

+ 例子：虚拟地址为32位
+ MMU对TLB查表：
  + 虚拟地址分为 **20位虚拟页号|12位页内地址** 
  + 20位虚拟页号分为Tag和组索引两部分
    + 由组索引查找在TLB的那一组，将tag与TLB中每组的标记字段进行比较，若发现相等且对应有效位为1，则TLB命中，通过TLB直接进行物理地址转换
    + TLB缺失，访问主存，虚拟页号分为**页目录索引**和**页表索引**（两级页表方式），转换地址后，需要将对应页表项内容送入TLB形成新的TLB表项：虚拟页号的高位部分作为TLB标记字段；若TLB满，还需进行替换

# 链接

+ 链接会关联所有可重定位目标文件生成可执行文件
+ 符号解析： 符号包括**全局静态变量名，函数名** ，
+ 重定位

## ELF

+ 链接视图：对应可重定位目标文件，由不同的节构成
+ 执行视图：对应可执行目标文件，由不同的段构成
+ .data节：已初始化的全局变量，.bss节：未初始化的全局变量，在目标文件中不占据实际的磁盘空间，.symtab:符号表，
+ 只读代码段：ELF头，程序头表，.init,.fini,.text,.rodata节
+ 可读可写数据段：.data节，.bss节
+ 按4KB边界对齐，则开始的位置最后三位为0：0x1000

### 存储器映像

+ 只读代码段映射到从虚拟地址为0x8048000开始的，可读写数据段映射到其后面按4KB对齐的高地址处，通常是0x8049000

## 符号解析

+ 对于某模块m：
  + 全局符号：在m中定义并被其他模块引用的，包括非静态的函数名和不带static属性的全局变量名
  + 外部符号：由其他模块定义并被m引用
  + 本地符号：在m中定义在m中引用

+ 函数中的局部变量是在运行时动态分配的，不是符号
+ 强符号：函数名，已初始化的全局变量名，**本地符号无强弱之分**
+ 弱符号：未初始化的全局变量名

## 重定位

+ 在符号解析的基础上将所有关联的目标模块合并，确定每个符号的地址：
  + 链接器将相同类型的节合并，确定新节中每个定义符号的位置
  + 对新节中引用符号重定位，指向对应的定义符号的起始处

+ 每个需重定位符号的重定位信息放在.rel.text和.rel.data节中
  + 采用PC相对寻址方式，有效地址为PC内容加上重定位后的32位地址
  + 采用绝对地址方式，有效地址为重定位后的32位地址

# 数据的机器级表示

##  浮点数表示

+ 第0位数符S,0或1，表示符号

+ 1-8位 阶码E

+ 9-31尾数M

+ R为基数

+ $X=(-1)^S * M * R^E$

  尾数M的位数反映了X的有效位，有效位数越多，表示精度越高

+ 表示范围$-(1-2^{-24})*2^{127}～-2^{-129},2^{-129}～(1-2^{-24})*2^{127}$

+ 定义浮点数中的0：机器0，或是落在正负下溢区间里的数

+ 一点讨论：浮点数比定点数能表示的数的范围更大，但是所能够表示的数并没有明显增多。所以数之间更不均匀，很稀疏。

## 原码

由符号位+数值位构成，0有+0和-0两种表示

## 补码

+ 正数补码符号为0，数值部分是它本身，负数补码为模大小-该 负数绝对值。
+ 0的补码表示是唯一的，全0
+ n位补码中，10000...表示最小负数$-2^{n-1}$
+ 负数补码求真值：数值部位各位取反后加1

## 浮点数运算

+ 首先进行对阶
  + 目的：使得两个操作数的阶码相同
  + 一般情况下，小阶码向大阶码对齐，小阶的尾数右移两阶的差的绝对值
+ 尾数相加

> 例子：计算0.5+（-0.4375）  
>
> > 对阶：$0.5 = 1.000*2^{-1},-0.4375 = -1.11*2^{-2}$  
> > 相加：$1.000*2^{-1}+(-0.111)*2^{-1} = 0.001*2^{-1}$  
> > 左规：$0.001*2^{-1} = 1.000*2^{-4}$  
> > 判断溢出：无。

### 附加位

IEEE754规定，由于表示能力有限，我们可以在浮点运算的中间结果右侧添加两个附加位(guard&round)  
附加位作用：用以保护对阶右移时的位，作为更加合适的舍入依据。

### 舍入位

在中间结果添加舍入位后，最终结果还需要一定的舍入方式进行舍入。

+ 默认舍入：舍入为最近可表示的数
  + 非中间值：0舍1入
  + 中间值：强迫结果为偶数
  + 具体而言，当附加位是01时舍去，当附加位为11时进位，当附加位为10时配成最近的偶数（如果LSB是1就加1，如果LSB是0就不变）
+ 朝$+\infty$方向舍入
+ 朝$-\infty$方向舍入
+ 朝0舍入：整数取小的最近值，负数取大的最近值。